# Quick Sort 
Quicksort is the widely used sorting algorithm that makes n log n comparisons in average case for sorting an array of n elements. It is a faster and highly efficient sorting algorithm. This algorithm follows the divide and conquer approach. Divide and conquer is a technique of breaking down the algorithms into subproblems, then solving the subproblems, and combining the results back together to solve the original problem.

## Divide: 
In Divide, first pick a pivot element. After that, partition or rearrange the array into two sub-arrays such that each element in the left sub-array is less than or equal to the pivot element and each element in the right sub-array is larger than the pivot element.
## Conquer: 
Recursively, sort two subarrays with Quicksort.
## Combine: 
Combine the already sorted array.


<image src="https://static.javatpoint.com/ds/images/quick-sort.png">
  
## Choosing the pivot
Picking a good pivot is necessary for the fast implementation of quicksort. However, it is typical to determine a good pivot. Some of the ways of choosing a pivot are as follows -

* Pivot can be random, i.e. select the random pivot from the given array.
* Pivot can either be the rightmost element of the leftmost element of the given array.
* Select median as the pivot element.
  
## Code:
  
```
#include<iostream>
using namespace std;
//for swapping the elements
void swap(int*a,int*b)
{
	int temp=0;
	temp=*a;
	*a=*b;
	*b=temp;
	return;
}

int partition(int arr[],int s,int e)
{
	int count=0;
	int i=s;
	int j=e;
  //for finding the postion where the pivot element will be
	for(int a=s+1;a<=e;a++)
	{
		if(arr[a]<arr[s])
		count++;
	}
	swap(arr[count+s],arr[s]);
  //for placing the element at its correct position
	while(i<count+s || j>count+s)
	{
		if(arr[i]<arr[count+s])
		{
			i++;
		}
		else if(arr[j]>arr[count+s])
		{
			j--;
		}
		else
		{
			swap(arr[j],arr[i]);
			j--;
			i++;
		}
	}
	return (count+s);
}
//code for dividing the array
void qs(int arr[],int s,int e)
{
	if(s<e)
	{
		int p=partition(arr,s,e);
		qs(arr,s,p-1);
		qs(arr,p+1,e);
	}
	else
	return;
}
int main()
{
	int n;
	int arr[10];
	cout<<"enter the no of array elements";
	cin>>n;
	cout<<"enter the array elements";
	for(int i=1;i<=n;i++)
	{
		cin>>arr[i];
	}
  //function call
	qs(arr,1,n);
  //for printing the sorted array
	for(int i=1;i<=n;i++)
	{
		cout<<arr[i]<<" ";
	}
	return 0;
}
```
                   
                   
## Time and Space Complexity Analysis:  
			       
### Time Complexity
* ### Best Case Complexity -
In Quicksort, the best-case occurs when the pivot element is the middle element or near to the middle element. The best-case time complexity of quicksort is O(n*logn).
* ### Average Case Complexity - 
It occurs when the array elements are in jumbled order that is not properly ascending and not properly descending. The average case time complexity of quicksort is O(n*logn).
* ### Worst Case Complexity - 
In quick sort, worst case occurs when the pivot element is either greatest or smallest element. Suppose, if the pivot element is always the last element of the array, the worst case would occur when the given array is sorted already in ascending or descending order. The worst-case time complexity of quicksort is O(n2).

			       
### The space complexity of quicksort is O(n*logn).
